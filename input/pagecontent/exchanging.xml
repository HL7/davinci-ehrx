<div xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://hl7.org/fhir ../../input-cache/schemas/R4/fhir-single.xsd">
  <p>
    FHIR offers numerous architectural for sharing data between systems.  Each of these approaches have pros and cons and are intended to be used in different circumstances.  This page
    provides an overview of each of the approaches, describes in general terms the general preference between the approaches based on their respective pros and cons, and provides a decision tree
    to guide choices about which approach best suits a particular circumstance.
  </p>
  <p>
    Note that the recommendations expressed here reflect the general beliefs of the community based on experience thus far.  However, other considerations will also impact implementation
    choices, including legacy infrastructure, the existing capabilities of communication partners, etc.  Following the guidance here is not required to claim FHIR conformance, however
    diverging from these recommendations may result in higher long-term implementation costs, fewer interoperability partners, or both.
  </p>
  <p>
    Not all of the options listed here were defined in early versions of FHIR.  It is likely that additional exchange alternatives will be identified by the FHIR community over time and,
    as the approaches become standardized/more broadly used and sufficient experience has been accumulated to advise on their use, this documentation will be updated to take them into
    account.  Feedback on the advice offered here is welcome - simply use the "Propose a Change" button at the bottom of the page.
  </p>
  <p>
    This page focuses on data access mechanisms either defined within the core FHIR specification or implementable using interfaces defined withing the FHIR specification without
    requiring any additional standardization.  Other access mechanisms may be possible, either defined in FHIR implementation guides or within other specifications.  For example, there's 
    a community effort outside the
    HL7 standardization process to allow a relational query interface to accessing FHIR information (see <a href="https://github.com/FHIR/sql-on-fhir">SQL-on-FHIR</a>).
  </p>
  <p>
    This guidance is provided as part of the HRex specification to guide future Da Vinci implementation guides in selecting their architectural approach.  As well, each implementation
    guide should identify the path(s) they've taken in navigating the tree to support their choices.  It is hoped that this will encourage consistency in approach across guides, as well
    as justifying situations where approaches vary.
  </p>
  <p>
    NOTE: This document focuses on FHIR as a means for exchange, but in theory, the principles described here would apply equally well to equivalent exchange mechanisms with other standards.
    For example, FHIR messaging would be similar to HL7 v2 and FHIR documents would be similar to HL7 CDA.  If using other standards, the set of architectural approaches to exchange are
    likely to be more limited than those available for FHIR.
  </p>
  <a name="approaches"> </a>
  <h3>Overview of approaches</h3>
  <p>
    This table provides an overview of the different approaches to data exchange.  Each approach includes a short description as well as a link to a page providing more detail about the 
    approach, including an interaction diagram demonstrating the
    flow pattern between the different systems.  As well, each approach includes a rating in terms of the degree of community support for the approach and the long-term re-useability 
    associated with implementing the approach.  Both are ranked as either 'low', 'medium' or 'high'.
  </p>
  <p>
    Community support is an assertion of the rough percentage of systems that implement
    FHIR that support a given capability.  'High' indicates that many/most systems that support data exchange will support the mechanism.  'Medium' indicates that there are a resonable
    number of implementations of the capability but support is not widespread.  'Low' indicates that few systems other than a few reference implementations are known to have production
    support for the mechanism.  Rankings are approximate and may not hold in all environments.  Where FHIR support is minimal, even a 'high' ranking may not result in much support.  
  </p>
  <p>
    Re-use indicates the amount of re-useability is likely to be achieved from implementing a particular interoperability solution.  'High' indicates that the approach is likely to be
    applicable to a broad set of use-cases with minimal/no redevelopment and little/no negotiation required to establish a functional interface.  'Medium' indicates that the approach has 
    a reasonable chance of utility for at least some other use-cases, though additional development and/or negotiation or configuration may be required.  'Low' indicates that the solution 
    is one-off and support for additional use-cases using the same mechanism is almost certain to require additional development.  Negotiation will be required to define what data will be
    sent and how it will be requested.
  </p>
  <p>
    As a rule, the less multipurpose and re-useable the communication mechanisms are and the more negotiation required to
    achieve interoperability, the greater the costs associated with the solution are likely to be.  That doesn't mean that architectural circumstances won't make the approaches necessary
    (and justify the increased cost), merely that if there's a choice between equally viable architectural alternatives, preference should generally be given to the one with lowest overall
    long-term cost.  The table below is ordered first by those that maximize long-term re-use and then by those that are most commonly supported in real production systems.  All things
    being equal, those appearing earlier in the table are likely to be better choices.  However, all things aren't equal, so consider the ratings in the table in parallel with the 
    decision tree found <a href="#decision-tree">following the table</a>.
  </p>
  
  <a name="approach-summary"> </a>
  <table class="grid">
    <thead>
      <tr>
        <th>Approach</th>
        <th>Re-use</th>
        <th>Adoption</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>
          <a href="exchanging-search.html#search">RESTful search</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>
          The <i>data consumer</i> uses the FHIR <a href="{{site.data.fhir.path}}search.html">search</a> to describe the desired data and, using <a href="{{site.data.fhir.path}}search.html#include">_include</a> and <a href="{{site.data.fhir.path}}search.html#revinclude">_revinclude</a>, the desired resources and the <i>data source</i> returns the requested information if available.
        </td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#batch">batch search</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>The <i>data consumer</i> sends a FHIR <a href="{{site.data.fhir.path}}http.html#transaction">batch</a> request to the <i>data source</i> containing multiple search, _filter, GraphQL, query and/or operation requests.  All of the requests are executed and the responses are returned in a batch response.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-polling.html">Polling</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>The <i>data consumer</i> queries the <i>data source</i> at regular intervals checking to see if there is new data that matches a particular criteria.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#transaction">Transaction Bundle</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>The <i>data source</i> creates a 'transaction' <a href="{{site.data.fhir.path}}bundle.html">Bundle</a> requesting the creation and/or updating of various resources and posts it to the RESTful endpoint of the <i>data consumer</i>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#batch">Batch Bundle</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>The <i>data source</i> creates a 'batch' <a href="{{site.data.fhir.path}}bundle.html">Bundle</a> requesting the creation and/or updating of various resources and posts it to the RESTful endpoint of the <i>data consumer</i>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#rest">REST actions</a>
        </th>
        <td>High</td>
        <td>High</td>
        <td>The <i>data source</i> POSTs or PUTs a single resource instance to the RESTful endpoint of the <i>data consumer</i>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#filter">_filter search</a>
        </th>
        <td>High</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> uses the FHIR <a href="{{site.data.fhir.path}}search.html">search</a>, <a href="{{site.data.fhir.path}}search_filter.html">_filter</a> or <a href="{{site.data.fhir.path}}graphql.html">GraphQL</a> mechanisms to describe the desired data and the desired data and the <i>data source</i> returns the requested information - if available.
        </td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-request.html#task">Task</a>
        </th>
        <td>High</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> creates a Task either on the <i>data source's</i> system or a system monitored by the <i>data source</i> requesting the sharing of data.  The <i>data source</i> then updates the Task with agreement to perform, progress status, and eventually a link to the requested data.  The <i>data consumer</i> monitors the Task by <a href="exchanging-subscription.html">subscription</a> or <a href="exchanging-polling.html">polling</a>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-subscription.html">Subscription</a>
        </th>
        <td>High</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> configures a subscription on the <i>data source</i> describing the type of data of interest and the events that should cause notification.  When the described event type(s) are triggered on the <i>data source</i> system, the <i>data source</i> pushes a notification to the <i>data consumer</i> either containing the desired data or prompting for the <i>data consumer</i> to query for the desired data.</td>
      </tr>
      <tr>
        <th>
          <a href="https://cds-hooks.hl7.org">CDS Hooks</a>
        </th>
        <td>High</td>
        <td>Moderate</td>
        <td>The <i>data source</i> makes a CDS Hooks request to the <i>data consumer</i> who is acting as a CDS Hooks Service.  The service than returns 0..* cards containing decision support content.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#patch">REST patch</a>
        </th>
        <td>High</td>
        <td>Low</td>
        <td>The <i>data source</i> uses PATCH to revise the information in a single resource instance via the RESTful endpoint of the <i>data consumer</i>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#graphql">GraphQL search</a>
        </th>
        <td>High</td>
        <td>Low</td>
        <td>The <i>data consumer</i> uses GraphQL to filter data from a resource instance, a RESTful query or an operation outcome, including information from related resources and selecting the specific elements desired and optionally flattening structures</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#sparql">SPARQL search</a>
        </th>
        <td>High</td>
        <td>Low</td>
        <td>The <i>data consumer</i> uses a local SPARQL engineto manipulate triples accessed by hitting a <i>data source's</i> RDF endpoint</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#cql">CQL search</a>
        </th>
        <td>High</td>
        <td>Low</td>
        <td>The <i>data consumer</i> invokes an operation specifying CQL to be invoked on the <i>data source</i> that will select and return a set of desired dataand receives back a search Bundle</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-request.html#request">CommunicationRequest</a>
        </th>
        <td>Moderate</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> creates a formal CommunicationRequest order and uses one of the <a href="{{site.data.fhir.path}}workflow-communications.html">workflow communication patterns</a> to ask the <i>data source </i> to fulfill the order.  The results are then returned using one of the <a href="#configured">push</a> mechanisms.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#document">FHIR Document</a>
        </th>
        <td>Moderate</td>
        <td>Moderate</td>
        <td>The <i>data source</i> assembles a collection of FHIR resources into a human-readable <a href="{{site.data.fhir.path}}documents.html">document</a> and transmits it to the <i>data consumer</i>.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-rest.html#collection">Collection Bundle</a>
        </th>
        <td>Moderate</td>
        <td>Moderate</td>
        <td>The <i>data source</i> assembles a collection of related resoruces into a 'collection' <a href="{{site.data.fhir.path}}bundle.html">Bundle</a> and creates or updates it on the <i>data consumer's</i> Batch endpoint</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-operation.html">FHIR Operation</a>
        </th>
        <td>Low</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> invokes a custom operation on the <i>data source</i> requesting information by parameters on the URL and/or in the body and the response to the operation (synchronous or asynchronous) contains the requested data.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-messaging.html">FHIR Messaging</a>
        </th>
        <td>Low</td>
        <td>Moderate</td>
        <td>The <i>data consumer</i> sends a FHIR message to the <i>data source</i> requesting information and the data source responds (synchronously or asynchronously) with a message containing the requested data.</td>
      </tr>
      <tr>
        <th>
          <a href="exchanging-search.html#query">Query search</a>
        </th>
        <td>Low</td>
        <td>Low</td>
        <td>The <i>data consumer</i> invokes a custom query operation on the <i>data source</i> and receives back a search Bundle</td>
      </tr>
    </tbody>
  </table>
  
  <a name="decision-tree"> </a>
  <h3>Decision points</h3>
  <p>
    With so many possible approaches to exchanging data, implementers need guidance on how to choose the appropriate choice for a given use-case.  In practice, the choice will be influenced by existing infrastructure, architectural preference and other considerations.  However, the following diagram and associated desciptions try to provide "best practice" guidance about what approach to use in which circumstances.  Adhering to the recommendations here are most likely to reduce long-term implementation effort and cost across the full data sharing community.  It will also hopefully increase the likelihood of FHIR solutions that are designed independently landing on the same architectural approach.  In all cases, if you're not completely certain on the best architectural approach for a given exchange, raise your questions on the <a href="https://chat.fhir.org/#narrow/stream/179166-implementers">chat.fhir.org implementer's forum</a>.  The community will often be able to provide additional considerations, guidance about what solutions already exist in the space and nudge you toward a solution that's most likely to successfully meet your requirements and integrate with other solutions.
  </p>
  <p>
    The following diagram provides a decision tree intended to guide the selection of exchange approach.  Each decision branch includes a hyperlink to a section further below that provides a detailed description of the considerations in making the choice for that decision point.  Each "exchange option" will link to a web page that provides a detailed walkthrough of the interoperability pattern and further guidance on its use - as well as pointing to the relevant portions of the FHIR spec that describe how to implement the approach.  While it's possible to use the decision tree while only paying attention to the branches 'relevant' for your particular use-case, readers are encouraged to familiarize themselves with all of the content so they can be sure they're not excluding options that may be relevant to their requirements.
  </p>
  <p>
    {% include fhir-exchanges.svg %}
    <b>FHIR exchange decision tree</b>
  </p>
  <a name="pull"> </a>
  <h4>Consumer initiates?</h4>
  <p>
    The first consideration is whether the desired data should be 'pulled' or 'pushed'.  In the <i>data consumer</i>-initiating 'pull' scenario, the event that initiates the exchange of data occurs in the <i>data consumer</i> system.  This might be a user clicking a button, or some sort of internal event that triggers a need for data.  The <i>data consumer</i> system is then responsible for determines what data to retrieve, when it should be returned and is responsible for initiating the flow by communicating with the <i>data source</i>.
  </p>
  <p>
    In the <i>data source</i>-initating (or 'pull') exchange, the event that determines the need for data to flow occurs in the system that owns the data.  This might be driven by human action, the creation or change of the data to be shared, or some other system event that makes it necessary to make the <i>data consumer</i> aware of a particular set of data.
  </p>
  <p>
    Notes:
  </p>
  <ul>
    <li>
      <i>Data source</i>-initiated data flows may include expectation for behavior on the part of the receiver, while <i>data consumer</i>-initiated flows generally don’t impose any such expectations - the consumer decides what to do with the data they've asked for.</li>
    <li>Some <i>data consumers</i> may be reluctant/unable to initiate data transfer for legal/policy reasons. I.e. It’s deemed acceptable to be pushed data, but not to pull it.  Typically this stems from right of access/permissions concerns where only the <i>data source</i> is deemed to have authority as to what information should be shared and when</li>
  </ul>
  <p>If the <i>data consumer</i> will initiate, the next choice is whether <a href="#human">human intervention is required</a>.  If the triggering for exchange will be driven by the <i>data source</i>, the next decision is whether the need to share the data is <a href="#configured">configurable by the <i>data consumer</i>
    </a>.</p>
  <a name="human"/>
  <h4>Human intervention?</h4>
  <p>
    When a <i>data consumer</i> asks for information from a <i>data source</i>, the next question is whether the request is purely at a system-to-system level where the request will be exclusively processed by software or whether there's the potential for humans to be involved in the preparation of the response.  Human involvement means that the request must arrive in a form such that it can be peristed until a human can look at it and that it provides sufficient contextual and descriptive information that a human understands what is needed.  Human involvement in responding to a request for data might occur for many reasons:
  </p>
  <ul>
    <li>The data might not exist in queriable electronic form.  It might only exist on paper, in someone's head or in some non-integrated third-party system.</li>
    <li>The data might not exist in a predictable location.  For example, different systems might store the relevant information in different resources, using different codes or categories, etc.  This means that the <i>data consumer</i> would not know the appropriate system-to-system query to use.  However, a human being at that specific location/organization would be aware of the organizational conventions and have a much better idea of how to find the data.  (Obviously, this need is minimized as standards impose tighter conventions for data representation and coding, but gaining consensus on and getting implementation of those standards can take considerable time.)</li>
    <li>The <i>data source</i> might not have the ability to filter the available data down to what's needed (and it would be impractical/inappropriate to share all of the candidate data).  A human who knows the system, on the other hand, might have access to local tools/knowledge that would allow finding the appropriate record(s) more easily.</li>
    <li>The description of the data to be returned and/or the description of the context that justifies the sharing of the data may not be amenable to expression in a computable form and require human interpretation/evaluation by someone specific to the <i>data source</i> to 'execute' the request</li>
    <li>There may be a need to organize, synthesize, and/or filter the data in a way that requires human cognition.  For standardized frequent queries, automation is often possible, but in some cases, automating all of the possibilities are impractical.</li>
    <li>There may be a lack of trust between the <i>data consumer</i> and the <i>data source</i>, such that the <i>data source</i> wishes to have human review of any data provided to ensure that the sharing is appropriate, necessary redaction is applied, appropriate approvals are in order, etc.</li>
  </ul>
  <p>
    Allowance for human intervention doesn't necessarily mean there will always <b>be</b> human intervention.  It's possible that some <i>data sources</i> will have an ability to handle certain requests in an automated fashion while others will be delegated to humans.  It's also possible that a <i>data source</i> will evolve to be capable of handling certain requests automatically that it couldn't in the past.  The key thing is that the interface is designed to allow for human intervention.
  </p>
  <p>
    Interfaces that allow for human intervention are intinsically asynchronous, though in some cases the asynchronous response may come quickly.  In general, automated interfaces are preferred to those allowing for human intervention.  First, if human intervention is actually required, that has a significant cost due to the expense of human time.  Second, human-intervention mechanisms involve more technical overhead (more layers, more data structures) which creates higher implementation and testing costs.  Finally, the lack of support for synchronous access means the solution isn't a good fit for certain use-cases, which may force multiple parallel access mechanisms (one for synchronous with no human intervention and one asynchronous with no human intervention).
  </p>
  <p>If the exchange will potentially require human intervention, the next decision is whether or not <a href="#formal">formal authorization is required</a>.  If the exchange will be fully automated, the next decision is whether the <a href="#hooks">CDS Hooks</a> is an appropriate solution.</p>
  <a name="formal"> </a>
  <h3>Formal authorization required?</h3>
  <p>
    There are two main mechanims in FHIR for requesting data from a human being (or potentially from a human being: <a href="{{site.data.fhir.path}}communicationrequest.html">CommunicationRequest</a> and <a href="{{site.data.fhir.path}}task.html">Task</a>.
  </p>
  <p>
    CommunicationRequest is used to represent proposals, plans and formal authorizations (orders) for data to flow.  In general, only a CommunicationRequest with an <code>intent</code> element of "order" or one of its specializations would be appropriate to trigger the exchange of information.  It is appropriate for use when there's a need for a formal order, along the same lines as a prescription, lab order, referral, etc.  CommunicationRequest, like other <a href="{{site.data.fhir.path}}request.html">Request</a> resources cannot ask for action on its own.  Instead, it must leverage one of the FHIR <a href="{{site.data.fhir.path}}workflow-communications.html">workflow communication patterns</a> to seek fulfillment of the specified request.  
  </p>
  <p>
    Task is used to explicitly ask for an action to be performed.  Sometimes it is used together with a Request resource, however it can also be used on its own to ask for execution of a simple action - such as requesting someone fill out a form or return a specified piece of information.  Because Task can be used to ask for an action to be performed and can, itself, track acceptance or rejection of the request, progress status of the request and eventually be updated to point to the 'output' of the request, it saves on overhead compared with using CommunicationRequest which (for any of the afore-mentioned functions) would need to be paired with Task.  As such, Task is generally preferred when there isn't a need for a formal authorization and when the capabilities of Task to describe the data requested are as sufficient as those available on CommunicationRequest.
  </p>
  <p>
    Details on using Task can be found <a href="exchanging-request.html#task">here</a>.  Details on using CommunicationRequest can be found <a href="exchanging-request.html#request">here</a>.  Note that, regardless of whether Task or CommunicationRequest are selected, the asynchronous response providing the requested data (or some of the requested data or an outright refusal to deliver the requested data) will be handled as a <a href="#configured">Data source-initiated (Push)</a> event and the architectural approach for that delivery will also need to be selected.  (Generally, the mechanism will be one of the <a href="#configured">Configured by consumer</a> options as the <i>data consumer</i> is the system that truly initiated the transfer and therefore should decide what happens to the data.  However, if an operation or message is used to transmit the Task or CommunicationRequest, then the response would come back as a <a href="exchanging-messaging.html">message</a> or an <a href="exchanging-operation.html">operation response</a>.
  </p>
  <a name="hooks"> </a>
  <h4>CDS Hooks?</h4>
  <p>
    The <a href="https://cds-hooks.hl7.org">CDS Hooks</a> specification should be used if the driver for the exchange is a user action within the <i>data consumer</i> in a context where the user is visually interacting with that system and the desired results will be limited clinical decision support guidance from the <i>data source</i> about their current action.  The specific requests and responses are not FHIR, though they can wrap FHIR data and also enable the data source and consumer roles to be reduced such that the decision support engine can access data from the clinical system to enable the provision of better decision support.  This aspect of the business flow would use <a href="#rest-search">RESTful search</a> or possibly one of the search alternatives beneath it.
  </p>
  <p>
    If hooks are to be used, the <a href="https://cds-hooks.hl7.org">CDS Hooks spec</a> provides details on the flow.  If CDS Hooks is not a good fit, the next question is whether the returning resources, the next decision point is whether <a href="#pre-exists">data is pre-existing</a>.  If not returning resources, the next decision point is whether the response will be expressed as a <a href="#resources">collection of FHIR resources</a>.
  </p>
  <a name="resources"> </a>
  <h4>Share whole resources?</h4>
  <p>
    In FHIR, data is represented using resources and, in most cases, when data is exchanged, it will be transferred as collections of those resources, though in some cases, information may be filtered out of the resources for reasons of privacy or more efficient communication.  Organizing returned data ensures that context is retained and provides a consistent framework for validating, parsing and consuming the shared data.  However, in some cases the use-case may call for returning an arbitrary collection of elements of interest, potentially joining content across multiple resources.  In general, the search mechanisms that return resources are more widely supported and will require less negotiation/modification of systems than those that return independent elements, so if either approach could work, it's best to take the 'return resources' branch in the decision tree.
  </p>
  <p>
    If returning resources, the next decision point is whether <a href="#pre-exists">data is pre-existing</a>.  If not returning resources, the next decision point is whether <a href="#graphql">GraphQL can meet the need</a>.
  </p>
  <a name="pre-exists"> </a>
  <h4>Is data pre-existing?</h4>
  <p>
    When requesting data to come back as resources, there are two possibilities - the <i>data consumer</i> is seeking data that is already persisted as existing records in the <i>data source's</i> system; or the <i>data consumer</i> is asking the <i>data source</i> to generate net new records - though potentially based on existing information.  The first case is a type of query and can generally be handled by relatively 'standard mechanisms in FHIR.  The latter will require a custom operation or message and will generally mean writing code specificaly to generate the desired data.
  </p>
  <p>
    If searching for pre-existing data, the next decision point is whether <a href="#rest-search">simple REST search</a> will satisfy the needs.  Otherwise, the choice is whether <a href="#message">messaging is appropriate</a>.
  </p>
  <a name="rest-search"> </a>
  <h4>REST searchable?</h4>
  <p>
    The most widely implemented search mechanism in FHIR is the RESTful <a href="{{site.data.fhir.path}}search.html">search</a> mechanism.  It defines mechanisms for retrieving resources along with related resources, filtering what resources are returned, ordering the result set and allowing data to be returned in individual pages.  It is a generic mechanism that is use-case independent.  As such, once a <i>data source</i> is able to respond to a query, it can (if it wishes) provide that data to any <i>data consumer</i>, regardless of the purpose for which the information is needed.
  </p>
  <p>
    However, the FHIR 'search' mechanism has limitations.  It's not possible to compose complex sets of 'and' and 'or' filters.  Each filter must target a single resource and can only bring back other resources if there is an explicit relationship.  As well, while it is theoretically possible to use deep chaining and nested includes to retrieve a wide variety of data, there are implementation costs that typically mean that most systems only support chaining and includes to a limited extent.  Implementers should consider the likelihood that requested search capabilities will exist in the relevant <i>data source(s)</i> and, if not, how much incremental effort would be required to add them and whether such mechanisms would be performant
    
  </p>
  <p>
    If REST search is appropriate the next question is to whether to support <a href="#synchronous">synchronous or asynchronous search</a>.  Otherwise the next option to evaluate is <a href="#search-batch">batch search</a>.
  </p>
  <a name="synchronous"> </a>
  <h4>Is synchronous</h4>
  <p>
    
  </p>
  <p>
    Details on invoking and processing RESTful requests in a synchronous manner is described <a href="exchanging-search.html#sync">here</a>.  Information about processing requests asynchronously is <a href="exchanging-search.html#async">here</a>.
  </p>
  <a name="search-batch"> </a>
  <h4>Batch searchable?</h4>
  <p>
    
  </p>
  <p>
    If batch searching is appropriate, details on the process can be found <a href="exchanging-search.html#batch">here</a>.  If not, the next architectural approach to consider is using <a href="#filter">_filter</a>.
  </p>
  <a name="filter"> </a>
  <h4>_filter searchable?</h4>
  <p>
    
  </p>
  <p>
    If _filter searching is appropriate, details on the process can be found <a href="exchanging-search.html#filter">here</a>.  If not, the next archictectural approach to consider is using <a href="#query">query</a>.
  </p>
  <a name="query"> </a>
  <h4>query searchable?</h4>
  <p>
    
  </p>
  <p>
    If a query operation will meet the need, details on the process can be found <a href="exchanging-search.html#query">here</a>.  If not, the next option to evaluate is <a href="#cql">CQL</a>.
  </p>
  <a name="cql"> </a>
  <h4>CQL searchable?</h4>
  <p>
    
  </p>
  <p>
    If CQL is appropriate, discussion on its use can be found <a href="exchanging-search.html#cql">here</a>.  Otherwise, the next option to explore is <a href="#message">messaging</a>.
  </p>
  <a name="message"> </a>
  <h4>Is message-like?</h4>
  <p>
    
  </p>
  <p>
    If the business case is more suitable to using messaging, details on the messaging approach can be found <a href="exchanging-messaging.html">here</a>.  Otherwise, details on operations can be found <a href="exchanging-operation.html">here</a>, though with operations there's also a need to determine whether support will be <a href="#synchronous">synchronous or asynchronous</a>.
  </p>
  <a name="graphql"> </a>
  <h4>GraphQL searchable?</h4>
  <p>
    
  </p>
  <p>
    If GraphQL is appropriate, details on its use are <a href="exchanging-search.html#graphql">here</a>.  If using GraphQL, the underlying server would typically also need <a href="#resources">resource search capabilities</a> to select the base resources against which the Graph will be evaluated.  As well, consideration will need to be given to whether the GraphQL calls should be <a href="#synchronous">synchronous or asynchronous.</a>  If GraphQL won't meet the need, the next option to explore is <a href="#sparql">SPARQL</a>.
  </p>
  <a name="sparql"> </a>
  <h4>SPARQL searchable?</h4>
  <p>
    
  </p>
  <p>
    If SPARQL is appropriate, discussion on its use can be found <a href="exchanging-search.html#sparql">here</a>.  Otherwise, the next option to explore is <a href="#cql">CQL</a>.
  </p>
  <a name="cql"> </a>
  <h4>CQL searchable?</h4>
  <p>
    
  </p>
  <p>
    If CQL is appropriate, discussion on its use can be found <a href="exchanging-search.html#cql">here</a>.  Otherwise, the next option to explore is <a href="#message">messaging</a>.
  </p>
  <a name="configured"> </a>
  <h4>Configured by consumer?</h4>
  <p>
    
  </p>
  <p>
    If the pushed data will be configured by the <i>data consumer</i>, the next question is whether <a href="#subscription">subsription</a> is viable.  If the <i>data consumer</i> won't be involved in determining what data gets pushed, the next question is whether the <i>data source</i> will <a href="#source-persist">control persistence</a>.
  </p>
  <a name="subscription"> </a>
  <h4>Subscription capability?</h4>
  <p>
    
  </p>
  <p>
    If subscriptions are appropriate, the next choice is whether the subscription notifications should <a href="#subscription-push">include data</a>.  If subscriptions are not viable, the appropriate solution is polling, which is described <a href="exchanging-polling.html">here</a>.  If polling is used the <a href="#rest-search">search</a> mechanism must also be selected.
  </p>
  <a name="subscription-push"> </a>
  <h4>Push notifications?</h4>
  <p>
    
  </p>
  <p>
    Details on how to use subscriptions with push notifications are <a href="exchanging-subscription.html#push">here</a>.  Subscriptions where the initial notification must be followed by a query are described <a href="exchanging-subscription.html#pull">here</a>.
  </p>
  <a name="source-persist"> </a>
  <h4>Data source directs consumer persistence?</h4>
  <p>
    
  </p>
  <p>
    If the <i>data source</i> will direct persistence in the <i>data consumer</i>, the next question is whether the data will be <a href="#group-store">stored as a group</a>.  If the <i>data source</i> won't be directing persistence, then the next decision point is evaluating the appropriateness of <a href="#message">messaging</a>.
  </p>
  <a name="group-store"> </a>
  <h4>Persist as a group?</h4>
  <p>
    
  </p>
  <p>
    If the need is for resources to be stored as a group, the next question is whether there's a need to support <a href="#story">presentation and/or story-telling</a>.  If the resources will be stored individually, the next question is whether there's a need to <a href="#group-transmit">transmit resources as a group</a>.
  </p>
  <a name="story"> </a>
  <h4>Focus on presentation/story-telling?</h4>
  <p>
    
  </p>
  <p>
    If there's a need to control presentation or provide story telling, then the exchange will be using FHIR documents, the process for which is described <a href="exchanging-rest.html#document">here</a>.  Othwerwise, the exchange will use 'collection' bundles and the process for that is described <a href="exchanging-rest.html#collection">here</a>.
  </p>
  <a name="group-transmit"> </a>
  <h4>Group transmission?</h4>
  <p>
    
  </p>
  <p>
    If group transmission is needed, the next question is whether <a href="#transaction">transactional behavior</a> is required.  If there's no need for group transmission, then simple REST creates or updates will be used, which is described <a href="exchanging-rest.html#rest">here.</a>
  </p>
  <a name="transaction"> </a>
  <h4>Transactional?</h4>
  <p>
    
  </p>
  <p>
    If transactional behavior is required, then the exchange will use FHIR transactions, which are defined <a href="exchanging-rest.html#transaction">here</a>.  Otherwise, exchange will use FHIR batch, which is described <a href="exchanging-rest.html#batch">here</a>.
  </p>
</div>
<!-- Todo Talk about: How significantly does the existence of intermediaries in exchanges impact the architecture. (e.g. reference re-writing or proxying in REST, etc.) -->